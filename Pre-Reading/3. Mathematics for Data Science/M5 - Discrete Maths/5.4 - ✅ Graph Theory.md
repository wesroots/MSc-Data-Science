---
Ex. Completed: true
tags:
  - maths
Links:
  - "[[3.1 - âœ… Matrices]]"
---
> [!note] Topic Overview
> (Definition)
> (Why it matters)
> 

# Basics
## Definition + formula
Network that helps define and visualise relationships between various components
- Vertices are not "raw data points" in the sense of rows in a CSV
- Vertices are abstract objects in a system
	- Each vertex is a relevant entity, edges capture relationships between them
![[Screenshot 2025-09-15 at 09.49.28.png]]
$$
G = (V,E)
$$
- $V$: vertices (or nodes) - the "objects"
- $E$: edges (or links) - "connections" between objects (relationships)
### Examples
- Social network
	- Vertices = people
	- Edges = friendships/follows
- Transport networks
	- Vertices = cities/stations
	- Edges = routes
- Knowledge graph
	- Vertices = concepts/entities
	- Edges = semantic relationships
## Weighted vs unweighted
### Unweighted graph
- Edges are either present or absent (yes/no)
### Weighted graph
- Each edge has a number (weight) - can represent distance, cost, capacity, etc.
## Simple vs multigraphs, self-loops
### Simple graph
- At most one edge between two vertices
- No self loops
### Multigraph
- Allows multiple edges between the same two vertices
	- E.g., two different airlines running flights between the same cities
### Self-loop
- An edge from a vertex back to itself
	- E.g., a webpage linking to itself

# Graph Representations
## Adjacency matrix
The adjacency matrix is mainly a representation tool
- Example: graph with vertices $A,B,C$:
$$
\begin{bmatrix} a_{AA}&a_{AB}&a_{AC}\\a_{BA}&a_{BB}&a_{BC}\\a_{CA}&a_{CB}&a_{CC} \end{bmatrix} = \begin{bmatrix} 0&1&0\\1&0&1\\0&1&0 \end{bmatrix}
$$
Its purpose it to encode the entire graph into a single matrix for:
1. Connectivity:
	- Immediate check: if $a_{AB} = 1$, then vertices $A$ and $B$ are connected
	- Powers of $a$: entry "$(a^k)_{AB}$" tells you the number of distinct paths of length $k$ from $A$ to $B$
2. Linear algebra bridge
	- Graph properties can be studied through $\mathbf{v}_i$ and $\lambda_i$ of the adjacency matrix
3. Algorithmic convenience
	- Matrix form makes it easy to apply algebraic operations, optimisations, and computer implementations
	- Useful in shortest-path algorithms (with weights), random walks, network analysis
## Adjacency list
An adjacency list is another way to store a graph. Instead of in a matrix, you keep track of each vertex's neighbours:
- E.g., a graph with vertices $A,B,C$:
	- $A:\{B\}$ -> $A$ is connected only to $B$
	- $B:\{A,C\}$ -> $B$ is connected to $A$ and $C$
	- $C:\{B\}$ -> $C$ is only connected to $B$
## Incidence matrix
- Rows = vertices, columns = edges
- Entry is 1 (or -1 in directed case) if a vertex touches an edge, 0 otherwise
	- E.g., edges $e_1 = A - B, e_2 = B-C$
$$
\begin{bmatrix} A&1&0\\B&1&1\\C&0&1 \end{bmatrix}
$$
Interpretation:
- Graph vertices -> $A,B,C$
- As rows $\equiv$ edges:
	- $R_2 \equiv e_1 = A-B$ -> $A$ and $B$ are connected
	- $R_3 \equiv e_2 = B-C$ -> $B$ and $C$ are connected

# Degree Concepts
## Degree of a node
The degree of a node = how many edges touch it
- Example in undirected graphs: 
	- Node $A$ connected to $B,C,D$
	- Degree of $A$ = 3
## Directed graphs: in-degree and out-degree
In directed graphs, edges are arrows
- In-degree -> no. of arrows pointing in
- Out-degree -> no. of arrows pointing out
## Degree distribution
Degrees across the whole graph - count of how many nodes have each frequency of degrees
- Example:
	- 2 vertices have 1 degree
	- 3 vertices have 2 degrees
	- 1 vertex has 5 degrees
Degree distribution tells you about network structure

# Special Graphs
## Complete graph $K_n$
- A graph where every vertex is connected to every other vertex
- Notation: $K_n$ has vertices and $\tfrac{n(n-1)}{2}$ edges
- Example: $K_3$ is a triangle, $K_4$ is a fully connected 4-node graph
- Maximum connectivity: used as a baseline in graph theory
## Bipartite graphs
- Vertices are split into two disjoint sets $U$ and $V$
- Edges only go between the sets, never within
- Example: user-item graphs in recommender systems
	- $U$ = users
	- $V$ = movies
- Models relationships between two different types of objects
## Trees (connected, acyclic graphs)
- A tree is a connected graph with no cycles
	- No cycles means you cannot trace a path of edges and vertices from a vertex back to itself without retracing an edge
- With $n$ vertices, it always has $n-1$ edges
- Example:
	- File system hierarchy
	- Decision trees in machine learning
- Unique path between any two nodes - hierarchical structure
## Paths
- Path: sequence of vertices connected by edges
	- Route from $A \to B \to C$
- Cycle: a path that starts and ends with the same vertex without repeating edges
	- $A \to B \to C \to A$
- Connectivity: whether the graph is "all in one piece"
	- Connected: there's a path between any two vertices
	- Disconnected: has separate components

# Graph Traversal
## Breadth-first search (BFS)
- Explore level by level
- Start from a source node
	1. Visit all neighbours
	2. Visit neighbours of neighbours
- Key property: in an unweighted graph, BFS finds the shortest path (fewest edges)
- Example use: finding the minimum number of "steps" between two people in a social network
## Depth-first search (DFS)
- Explore as deep as possible along one branch, then backtrack
- Key property: good for exploring structure, not shortest paths
- Common uses:
	- Discovering connected components
	- Detecting cycles
	- Building spanning trees

# Shortest paths
## Dijkstra's algorithm
Given a weighted graph and a starting vertex, it finds the minimum distance from the start to every other vertex
### How it works (step-by-step)
1. Initialisation
	- Distance to start = 0
	- Distance to all others = assumed $\infty$ (unknown)
2. Pick the next vertex
	- Among all unvisited vertices, choose the one with the smallest current distance
3. Relax neighbours
	- Check if going through the current vertex gives a shorter path to all of the initial vertex's neighbours - update if it does
	- $$\text{newDist} = \text{dist[current] + weight(edge)}$$
	- If $\text{newDist} < \text{dist/neighbour}$, update the neighbour's distance
4. Mark vertex as visited
	- Once processed, it won't change again
5. Repeat until all vertices are visited
## Importance of shortest path
- Routing
	- Shortest driving route
- Recommendation systems
	- Shortest connection path between users and items
- Network analysis
	- Finding influential nodes, efficient message passing

# Graph Properties
## Connectivity
- A graph is connected if there's a path between every pair of vertices
- If not -> it breaks into components
- In data science:
	- Social networks -> check if everyone is reachable
	- Web graphs -> is there a route from one page to another
## Cliques and communities
- Clique - a subset of vertices where every vertex is connected to every other
- Community - looser version -> groups of nodes with dense connections internally buy fewer connections outside
## Diameter and path length
- Path length - number of edges between two vertices along a path
- Diameter - the longest shortest-path distance in the whole graph
	- "How far apart are the two most distant nodes"
- Importance: small diameters mean "small-world" networks
- Path lengths matter for efficiency of communication, routing, etc.

# Applications in Data Science
- *Social networks* -> nodes = users, edges = friendships/interactions. Used to study influence, spread of info
- *Recommendation systems* -> bipartite graph: one set = users, other = items, links = ratings/purchases
- *Knowledge graphs* -> nodes = entities (people, places), edges = relationships (works at, located in). Basis for search engines
- *Graph based ML* -> use graph structure in models
	- Node classification - predict user type
	- Link prediction - will two users connect
	- Clustering - group similar nodes
- *Trees* - special graphs used in decision trees (for prediction) and hierarchical clustering (organising data)
